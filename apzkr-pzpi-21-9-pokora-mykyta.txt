Міністерство освіти і науки України
Харківський національний університет радіоелектроніки

Факультет комп’ютерних наук

Кафедра програмної інженерії

КУРСОВА РОБОТА
ПОЯСНЮВАЛЬНА ЗАПИСКА
з навчальної дисципліни «Архітектура програмного забезпечення»
Тема роботи: Програмна система для догляду за рибками

Студент гр. ПЗПІ-21-9		 __________________ Покора М. І.
(підпис)
Керівник роботи 			___________________ ст.викл. Сокорчук І.П.
(підпис)
Роботу захищено «__»_________2024 р.
з оцінкою _________________________

Комісія: 				___________________ доц. Лещинський В.О.
(підпис)
___________________ доц. Лещинська І.О.
(підпис)
___________________ ст.викл. Сокорчук І.П.
(підпис)


Харків
2024 р.

Харківський національний університет радіоелектроніки

Факультет комп’ютерних наук Кафедра програмної інженерії
Спеціальність 121 – Інженерія програмного забезпечення
Курс                     3                     Семестр 	                  6
Навчальна дисципліна Архітектура програмного забезпечення

ЗАВДАННЯ
НА КУРСОВУ РОБОТИ СТУДЕНТОВІ
                                             Покорі Микиті Івановичу
1. Тема проекту: Програмна система для догляду за рибками
2. Термін узгодження завдання з лабораторних робіт «_18_»_березня_ 2024 р.
3. Термін здачі завдання з лабораторних робіт «   06    »      червня     2024 р.
4. Вихідні дані до проекту: Програмна система, призначена для централізованого управління процесами в акваріумістиці. Система надає можливості створення компаній, розподілу областей відповідальності (ролей), керування акваріумами та рибками в ньому. Включає інтеграцію з IoT-пристроями для віддаленого годування за розкладом або ручним годуванням, моніторинг показників води та генерування звітів. Система повинна складатися з серверної частини, клієнтської частини та IoT-компонентів. Використовувати технології: СУБД PostgreSQL, React для клієнтської частини (web), FastAPI та Python (серверна частина), C++ (IoT-частина), Firebase (автентифікація користувачів)
5. Зміст звітів з лабораторних робіт (перелік питань, що належить розробити):
вступ, аналіз предметної області, аналіз вимог та специфікація системи, проектування бази даних системи, архітектура програмної системи, опис розробленої програмної системи, висновки, перелік посилань,  додатки
6. Перелік графічного матеріалу (діаграми, рисунки, інтерфейси):
UML діаграма розгортання, UML діаграма прецедентів, UML діаграма активності, ER-модель даних, UML діаграма компонентів
КАЛЕНДАРНИЙ ПЛАН
№	Назва етапів курсової роботи	Термін виконання
етапів	Примітка
1	Функціональна специфікація
програмного проекту	19.07.24	Виконано
2	Проектування програмного
проекту	25.07.24 - 29.07.24	Виконано
3	Кодування програмного проекту	03.08.24 - 10.08.24	Виконано
4	Оформлення пояснювальної
записки	10.08.24 - 14.08.24	Виконано
5	Захист курсової роботи	17.08.24	Виконано

Дата видачі теми проекту «__18__»____ березня____2024 р.
Керівник 				 ______________ ст.викл. Сокорчук І.П.
(підпис)
Завдання прийняв до виконання
ст.гр. ПЗПІ-21-9			 _____________		_Покора М. І._
         (підпис)

РЕФЕРАТ


Пояснювальна записка до курсової роботи: 93 с., 20 рис., 3 таблиці, 4 додатків, 5 джерел.
ГОДУВАННЯ РИБОК, ЗВІТНІСТЬ, РОЗУМНИЙ ПРИСТРІЙ, ПРОГРАМНА СИСТЕМА, БЕЗЛІЧ КОМПАНІЙ, ФОНОВІ ПРОЦЕСИ.

Об'єктом дослідження є сфера аквакультури, що охоплює проблеми управління акваріумами, автоматизації догляду за рибами та оптимізації робочих процесів у компаніях, що займаються розведенням водних організмів. Для реалізації проекту було обрано тему автоматизації догляду за рибками, зокрема годування та контроль параметрів середовища акваріумів. Програмна система отримала назву "FinFare". Ця платформа дозволяє користувачам створювати та керувати компаніями, додавати працівників в компанії та давати кожному обов'язки у вигляді ролей, здійснювати моніторинг акваріумів та контролювати годування риб за допомогою IoT-пристроїв. Система підтримує 2 мови: українську та англійську.
У результаті ми отримали наступні частини системи: серверну частину (backend), розроблену на мові програмування Python з використанням фреймворку FastAPI; реляційну базу даних PostgreSQL для зберігання та управління даними; веб-інтерфейс користувача, створений на JavaScript з використанням бібліотеки React; IoT-компонент, реалізований на C++ для керування пристроями контролю акваріумів; систему авторизації, інтегровану з Firebase. Усі ці компоненти разом формують цілісну екосистему "FinFare" для ефективного управління аквакультурою та пов'язаними бізнес-процесами.

ЗМІСТ


ВСТУП	7
1	АНАЛІЗ ПРЕДМЕТНОЇ ОБЛАСТІ	9
1.1	Бізнес-вимоги	9
1.1.1	Бізнес-можливості	9
1.1.2	Бізнес-цілі та критерії успіху	11
1.1.3	Потреби клієнтів або ринку	12
1.1.4	Бізнес-ризики	13
1.2	Концепція рішення	14
1.2.1	Окреслення концепції	14
1.2.2	Головна функціональність	15
1.2.3	Припущення та залежності	16
1.3	Рамки та обмеження проекту	17
1.3.1	Рамки первинного випуску	17
1.3.2	Рамки наступних випусків	18
1.3.3	Обмеження та винятки	19
1.4	Бізнес-контекст	20
1.4.1	Профілі зацікавлених сторін	20
1.4.2	Пріоритети проекту	21
1.4.3	Робоче середовище	22
2	АНАЛІЗ ВИМОГ ТА СПЕЦИФІКАЦІЯ СИСТЕМИ	23
2.1	Типи користувачів та їх функціонал	23
2.1.1	Зареєстрований користувач:	23
2.1.2	Власник компанії:	23
2.1.3	Користувач за призначеною роллю в компанії:	24
2.2	Загальний функціонал системи:	24
3	ПРОЕКТУВАННЯ БАЗИ ДАНИХ СИСТЕМИ	25
3.1	Розробка ER-діаграми	25
3.2	Опис сутностей, їх полів та взаємозв'язків	25
3.3	Опис зв’язків між сутностями	29
4	АРХІТЕКТУРА ПРОГРАМНОЇ СИСТЕМИ	31
4.1	Загальна архітектура системи	31
4.2	Архітектура серверної частини	32
4.2.1	Специфікація REST API	34
4.3	Архітектура клієнтської частини	39
4.4	Архітектура IoT-компоненту	40
4.5	Взаємодія користувачів з системою	41
5	ОПИС ІНТЕРФЕЙСУ ТА ФУНКЦІОНАЛЬНОСТІ СИСТЕМИ	43
5.1	Вхід до системи	43
5.2	Вибір компанії	44
5.3	Створення нової компанії	45
5.4	Навігація по системі	46
5.5	Управління акваріумами	46
5.6	Управління пристроями	47
5.7	Управління годівницями	50
5.8	Управління компанією	51
5.9	Профіль користувача	55
5.10	Зміна мови інтерфейсу	56
ВИСНОВКИ	57
ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ	58
ДОДАТОК А	59
ДОДАТОК Б	79
ДОДАТОК В	87
ДОДАТОК Г	93


ВСТУП


У сучасному світі акваріумістика стала не просто хобі, а й важливою частиною багатьох сфер життя - від домашнього інтер'єру до професійних досліджень морської біології. Акваріуми прикрашають офіси, ресторани, готелі, створюючи унікальну атмосферу та підкреслюючи статус закладу. Проте утримання акваріума, особливо великого чи спеціалізованого, вимагає значних знань, уваги та ресурсів.
Власники акваріумів, від любителів до професіоналів, стикаються з низкою викликів. Регулярне годування риб, контроль якості води, підтримка оптимальної температури та освітлення - це лише базові завдання, які потребують постійної уваги. У великих компаніях, що займаються аквакультурою, ці проблеми множаться на кількість акваріумів, створюючи складну систему управління.
Наприклад, власник мережі ресторанів вирішує встановити акваріуми у кожному закладі для створення особливої атмосфери. Для цього йому необхідно найняти спеціалістів з догляду за рибами, організувати систему контролю параметрів води та годування у кожному ресторані. Без автоматизації цей процес стає надзвичайно трудомістким та схильним до людських помилок.
Традиційні методи ведення обліку та контролю за акваріумами часто включають ручні записи, що призводить до неточностей, втрати даних та неефективного використання ресурсів. Відсутність централізованої системи управління ускладнює координацію дій між різними відділами чи філіями компанії, що займається аквакультурою.
Саме для вирішення цих проблем була розроблена система "FinFare". Вона автоматизує всі аспекти управління акваріумами та аквакультурою через єдиний інтерфейс.
Однією з ключових інновацій "FinFare" є революційний підхід до годування риб. Система пропонує два варіанти: ручне годування через веб-інтерфейс та повністю автоматизовану систему з налаштуванням розкладу.
Впровадження "FinFare" відкриває нові можливості для оптимізації процесів в аквакультурі. Завдяки IoT-пристроям, система забезпечує точний контроль за умовами в акваріумах.
Для компаній, що займаються аквакультурою, "FinFare" стає незамінним інструментом управління. Система дозволяє ефективно розподіляти обов'язки, вести облік ресурсів та надає аналітичні дані.
Таким чином, "FinFare" стає комплексним рішенням, яке трансформує підхід до управління акваріумами та аквакультурою, поєднуючи передові технології з розумінням потреб галузі.

1	АНАЛІЗ ПРЕДМЕТНОЇ ОБЛАСТІ
1.1	Бізнес-вимоги
1.1.1	Бізнес-можливості

Програмна система FinFare розроблена для задоволення потреб глобального ринку акваріумістики, пропонуючи інноваційне рішення для автоматизації та централізованого управління процесами догляду за акваріумами. Система призначена для широкого кола користувачів, від любителів до професійних акваріумістів та великих компаній, що займаються розведенням водних організмів.
Розглянемо аналоги на ринку. Neptune Systems (Apex Fusion) пропонує інтегровану систему для моніторингу та керування акваріумом через зручний інтерфейс. Користувачі можуть відстежувати параметри води, керувати освітленням, температурою та іншими аспектами акваріумного середовища. Однак, вона може виявитися витратною та обмеженою в можливостях автоматизації порівняно з FinFare. На відміну від Neptune Systems, FinFare пропонує більш доступне рішення з розширеними можливостями автоматизації, що робить її привабливою для ширшого кола користувачів.
Інший аналог - Seneye, який пропонує систему моніторингу води, що дозволяє користувачам віддалено відстежувати параметри води через мобільний додаток. Крім того, вона надає можливість отримувати сповіщення про зміни у водних параметрах. Проте його можливості автоматизації та аналітики можуть бути обмеженими у порівнянні з FinFare. FinFare, на відміну від Seneye, пропонує не лише моніторинг, але й комплексне управління акваріумом, включаючи розширені аналітичні інструменти та автоматизацію процесів.
GHL (Profilux Touch) пропонує високофункціональну систему для моніторингу та керування акваріумом, включаючи можливість інтеграції з різними системами та налаштування параметрів за допомогою сенсорного екрану. Проте його вартість та складність використання можуть бути обмежувальними факторами для деяких користувачів. FinFare вирішує ці проблеми, пропонуючи інтуїтивно зрозумілий інтерфейс та більш доступну цінову політику, що робить її привабливою для широкого кола користувачів.
FinFare має суттєві переваги над розглянутими аналогами. По-перше, система пропонує оптимальний баланс між функціональністю та простотою використання. По-друге, FinFare забезпечує більш гнучкі можливості автоматизації та розширену аналітику, що дозволяє користувачам ефективніше управляти своїми акваріумами. По-третє, система має більш привабливу цінову політику, роблячи передові технології доступними для ширшого кола користувачів.
Система FinFare планує використовувати модель монетизації через надання доступу до системи. Пропонуються різні тарифні плани: безкоштовний пробний період на 1 місяць, стандартний план з доступом до основних функцій, та преміум план з розширеними можливостями аналітики та API-інтеграції. Додатково, компанія планує надавати послуги з впровадження системи, інтеграції з іншими системами та допомоги в оптимізації догляду за акваріумами.
Проект FinFare має значний потенціал для розвитку, враховуючи зростаючий інтерес до акваріумістики та потребу в ефективних системах управління. З розширенням ринку, все більше користувачів та компаній потребуватимуть подібних програмних систем для оптимізації своєї роботи та підвищення якості догляду за водними організмами.

1.1.2	Бізнес-цілі та критерії успіху


БЦ-1: Розширення ринкової присутності:
БЦ-1.1: Розширення ринкової присутності в п'яти нових регіонах протягом наступного року.
БЦ-1.2: Підписання партнерських угод з мінімум десятьма компаніями з галузі акваріумістики в кожному новому регіоні.
БЦ-2: Підвищення ефективності та зручності користування:
БЦ-3: Збільшення прибутковості та оптимізація витрат:
БЦ-3.1: Збільшення обсягу клієнтів на 20% в порівнянні з попереднім роком шляхом розробки та реалізації маркетингових стратегій.
БЦ-3.2: Оптимізація процесів управління акваріумами та годуванням рибок для зниження накладних витрат на 15%.
КУ-1: Задоволеність клієнтів та партнерів:
КУ-1.1: Досягнення рівня задоволеності клієнтів не менше 90% на основі зворотного зв'язку та оцінок послуг.
КУ-1.2: Укладання партнерських угод з не менше ніж 80% клієнтів на постійній основі.
КУ-2: Успішність використання продукту:
КУ-2.1: Забезпечення безперебійної роботи системи управління акваріумами протягом 99% часу.
КУ-2.2: Здійснення інтеграції системи FinFare з існуючими IoT девайсами у не менше ніж 95% акваріумів, що використовуються клієнтами.

1.1.3	Потреби клієнтів або ринку


Потреба в точному моніторингу:
-	Клієнти бажають систему, яка забезпечить точне вимірювання параметрів в акваріумах, таких як температура води, рівень pH, концентрація кисню тощо. Вони вимагають високої точності, оскільки навіть невеликі зміни можуть впливати на здоров'я рибок.
Зручність в управлінні та застосуванні:
-	Клієнти шукають систему з інтуїтивним і легким у використанні інтерфейсом. Вони хочуть мати можливість моніторити стан своїх акваріумів та керувати ними з будь-якого місця за допомогою зручного мобільного додатку або веб-інтерфейсу.
Оптимізація використання ресурсів:
-	Клієнти прагнуть ефективно використовувати ресурси, такі як корм та енергія для роботи системи. Вони очікують, що система буде оптимізувати процес годування рибок та інші операції з мінімальними витратами ресурсів.
Система адаптації до різних типів риб:
-	Клієнти хочуть мати можливість налаштувати систему для моніторингу та годування різних видів рибок з різними вимогами до харчування та умов утримання.
Підтримка технічної підтримки та сервісу:
-	Клієнти очікують наявності технічної підтримки та можливості отримання консультацій з використання системи та вирішення технічних питань у разі необхідності. Вони цінують надійний сервіс та швидку відповідь на їхні запити.

1.1.4	Бізнес-ризики


Технічні проблеми:
-	Існує ризик виникнення технічних проблем, таких як несправності датчиків або систем автоматизації, що може призвести до неточного моніторингу параметрів в акваріумах, недостатнього або надмірного годування рибок, а також несправностей в системі живлення риб. Це може спричинити стрес для риб, погіршити їхнє здоров'я та знизити якість послуг.
Низька прийнятність ринку:
-	Ризик недостатнього попиту на програмні системи моніторингу акваріумів через низьку обізнаність ринку або недостатню зацікавленість потенційних клієнтів.
Конкуренція:
-	Існує ризик конкуренції з існуючими та майбутніми конкурентами, які також пропонують послуги з управління акваріумами та годування рибок. Конкуренція може призвести до зниження цін, покращення якості продукту або послуги, або зменшення частки ринку для компанії.
Невідповідність вимогам користувачів:
-	Ризик полягає в тому, що розроблена система може не відповідати вимогам або очікуванням користувачів, що може призвести до незадоволення клієнтів та втрати довіри до компанії. Недостатня якість моніторингу риб та управління акваріумами також може погіршити стан риб та призвести до втрати клієнтів.
Фінансові ризики:
-	Ризик обмежених фінансових ресурсів, що може призвести до затримок у розробці, впровадженні продукту та обмежити можливості розвитку бізнесу.

1.2	Концепція рішення
1.2.1	Окреслення концепції


Даний продукт необхідний для надання компаніям, які утримують акваріуми з рибами, інструменту для точного контролю умов утримання риб, зокрема вологості води, температури та режиму годування. Впровадження програмної системи дозволить користувачам ефективно керувати умовами утримання риб, забезпечуючи оптимальні умови для їхнього здоров'я та розвитку.
Основні переваги цього продукту полягають у зменшенні зусиль та ресурсів, необхідних для моніторингу та годування риб. Програмна система надає автоматизований механізм, який виявляє потреби риб у годуванні та керує процесом годування автоматично. Це дозволяє зменшити витрати на корм, енергію та час, необхідний для управління акваріумами.
Впровадження програмної системи моніторингу та годування риб допоможе компаніям досягти оптимальних результатів у утриманні риб. Вони зможуть забезпечити регулярний контроль та годування риб, підтримувати оптимальні умови для здоров'я та розвитку риб, а також ефективно використовувати ресурси.
Програмна система моніторингу та годування риб є інноваційним рішенням, яке допоможе оптимізувати процес утримання риб і підвищити ефективність управління акваріумами з рибами.

1.2.2	Головна функціональність


ГФ-1: Реєстрація та авторизація користувачів.
ГФ-2: Моніторинг рівня кисню, pH, солоності, температури в акваріумі у реальному часі.
ГФ-3: Автоматичне налаштування годування риб на основі даних користувача.
ГФ-4: Автоматичне включення та вимкнення системи годування відповідно до заданих графіків.
ГФ-5: Повідомлення відповідних осіб про нестачу корму або несправності системи.
ГФ-6: Запис та аналіз даних про рівень кисню та годування риб.
ГФ-7: Можливість дистанційного керування системою через веб-інтерфейс.
ГФ-8: Технічна підтримка користувачів для вирішення технічних питань та надання порад та рекомендацій щодо використання системи.
ГФ-9: Створення та управління віртуальними компаніями в рамках системи.
ГФ-10: Управління ролями та правами доступу для різних користувачів в межах однієї компанії.
ГФ-11: Ведення обліку риб (додавання нових, видалення при втраті, ведення статистики).
ГФ-12: Інтеграція з IoT-пристроями для автоматизованого збору даних та керування обладнанням.
1.2.3	Припущення та залежності


При-1: Для кожного акваріума, в якому тримаються рибки, потрібно налаштувати відповідні параметри та допустимі діапазони рівня кисню та годування риб.
При-2: Для кожного акваріума може бути налаштований окремий графік годування риб, залежно від їхніх потреб та кількості.
При-3: Встановлені датчики повинні бути сумісними з програмним забезпеченням системи та надавати точні виміри всіх контрольованих параметрів (кисень, температура, солоність, pH).
При-5: Система має можливість підключення до інтернету для забезпечення віддаленого доступу та оновлень.
При-6: Користувачі мають смартфони або комп'ютери для доступу до веб-інтерфейсу системи.
Зал-1: Дані про всі параметри води (рівень кисню, температура, солоність, pH) та годування риб будуть збиратися та передаватися датчиками правильно та точно.
Зал-2: Користувачі системи повинні належним чином встановити та налаштувати всі датчики та пристрої автоматичного годування для правильного функціонування системи.
Зал-3: Система повинна мати постійний доступ до електроенергії для живлення датчиків, пристроїв годування та інших компонентів системи.
Зал-4: Наявність стабільного інтернет-з'єднання для передачі даних та забезпечення віддаленого доступу.
Зал-5: Сумісність IoT-пристроїв (датчиків, годівниць) з програмним забезпеченням системи FinFare.
Зал-6: Відповідність системи законодавчим нормам щодо утримання водних організмів та захисту даних користувачів.

1.3	Рамки та обмеження проекту
1.3.1	Рамки первинного випуску


У веб-застосунку користувачі матимуть можливість:
-	реєструватися та авторизуватися;
-	створювати компанії та управляти ролями користувачів;
-	переглядати дані про рівень кисню, температуру, солоність, pH та годування риб;
-	встановлювати графіки автоматичного годування
-	вимірювати та записувати дані про рівень годування;
-	отримувати сповіщення про стан рівня кисню та годування риб;
-	налаштовувати параметри системи відповідно до потреб кожного акваріуму;
До функціоналу IoT відноситься:
-	під'єднання датчиків до акваріуму (кисень, температура, солоність, pH);
-	автоматичне годування риб за встановленим графіком;
-	збір та передача даних про параметри води в реальному часі;
Головна функціональність:
ГФ-1: Реєстрація та авторизація
ГФ-2: Створення та управління компаніями
ГФ-3: Створення та управління акваріумами
ГФ-4: Управління ролями користувачів
ГФ-5: Перегляд даних про параметри води та годування риб
ГФ-6: Вимірювання та запис даних про параметри води
ГФ-7: Автоматичне налаштування годівельного режиму
ГФ-8: Перевірка стану датчиків
ГФ-9: Автоматичне включення та вимкнення системи годування
ГФ-10: Технічна підтримка користувачів
1.3.2	Рамки наступних випусків


У веб-застосунку користувачі будуть мати можливість:
-	автоматично налаштовувати режим годування на основі типу рибок та їх фізичних даних;
-	встановлювати певні параметри якості води та кількості кисню у воді;
-	відстежувати запис та аналіз історичних даних про якість води та кількість кисню у воді;
-	автоматичного керування системою через веб застосунок.
Адміністратор у веб-застосунку буде мати можливість:
-	відповідати на техпідтримку.
У мобайл-застосунку користувачі також будуть мати можливість:
-	автоматично налаштовувати режим годування на основі типу рибок та їх фізичних даних;
-	відстежувати запис та аналіз історичних даних про якість води та кількість кисню у воді;
-	автоматичного керування системою через мобільний додаток.
Головна функціональність:

MF-4: Автоматичне керування системою освітлення та фільтрації
Система забезпечить автоматичне управління освітленням та фільтрацією у акваріумі, забезпечуючи оптимальні умови для риб та рослин.

MF-6: Віддалене керування системою через мобільний додаток
Користувачі матимуть можливість віддалено керувати параметрами акваріуму через зручний мобільний додаток.

MF-8: Запис та аналіз історичних даних про параметри акваріуму
Система зберігатиме історичні дані про всі параметри акваріуму для подальшого аналізу та оптимізації умов утримання риб.

MF-9: Техпідтримка користувачів
Користувачі отримають технічну підтримку та консультації з усіх питань, пов'язаних із використанням системи управління акваріумом.


1.3.3	Обмеження та винятки


Обмеження та винятки:
-	Залежність від доступу до електроенергії: Система моніторингу та автоматичного керування акваріумом може потребувати постійного джерела електроенергії для свого безперебійного функціонування. У випадку відсутності електроенергії, деякі функції системи можуть бути обмежені або недоступні.
-	Підключення до мережі Інтернет: Для забезпечення дистанційного керування та зв'язку з системою через мобільний додаток або веб-інтерфейс необхідне підключення до мережі Інтернет. Відсутність доступу до Інтернету може призвести до обмеження можливостей дистанційного керування та збору даних.
-	Зовнішні впливи: Зовнішні фактори, такі як температура навколишнього середовища, рівень вологості або наявність прямих сонячних променів, можуть впливати на роботу датчиків та точність їхніх вимірювань. Система повинна мати можливість адаптуватися до таких зовнішніх впливів та надавати відповідні поправки для забезпечення оптимальних умов для риб.
-	Затримка отримання даних з датчиків: Дані з датчиків можуть отримуватися з певною затримкою. Це може бути пов'язано з технічними аспектами, такими як передача даних, час реакції датчика тощо.
1.4	Бізнес-контекст
1.4.1	Профілі зацікавлених сторін


Таблиця 1.1 – Профілі зацікавлених сторін
Показник	Виконання (етапи)	Обмеження (граничні значення)	Ступінь свободи (допустимий діапазон)
План робіт	Продукт має бути випущеним приблизно до 30.06.2024		Можливе відхилення від графіку на 1-3 місяців
Функціональність			100% функціоналу має працювати на релізі 1.0
Якість			100% всіх наявних данних з датчиків повинні бути вірними
Персонал		Максимальний розмір команди це 1 розробник та адміністратор
Ціна		≈ 10 000 гривень	Допустиме відхилення на 15%


1.4.2	Пріоритети проекту


Таблиця 1.2 – Пріоритети проекту
Показник	Виконання (етапи)	Обмеження (граничні значення)	Ступінь свободи (допустимий діапазон)
План робіт	Продукт має бути випущеним приблизно до 30.06.2024		Можливе відхилення від графіку на 1-3 місяців
Функціональність			100% функціоналу має працювати на релізі 1.0
Якість			100% всіх наявних данних з датчикыв повинні бути вірними
Персонал		Максимальний розмір команди це 1 розробник та адміністратор
Ціна		≈ 10 000 гривень	Допустиме відхилення на 15%


1.4.3	Робоче середовище


Система автоматизації управління аквакультурою "FinFare" складається з серверної частини, веб-застосунку та IoT-компоненту.
Для розробки серверної частини обрано мову програмування Python з використанням фреймворку FastAPI. Ця комбінація забезпечує високу продуктивність, асинхронну обробку запитів та зручність розробки API. Python також має багату екосистему бібліотек для роботи з даними та машинного навчання, що може бути корисним для майбутнього розвитку системи.
Система управління базами даних PostgreSQL була обрана для зберігання даних. PostgreSQL відома своєю надійністю, підтримкою складних запитів та можливістю масштабування, що важливо для роботи з великими обсягами даних про параметри води та поведінку риб.
Веб-застосунок розробляється з використанням JavaScript та бібліотеки React. Для прискорення розробки та забезпечення уніфікованого дизайну використовуються готові компоненти з бібліотеки Material-UI (MUI). Це дозволяє створювати професійний та інтуїтивно зрозумілий інтерфейс, зосереджуючись на реалізації ключової функціональності системи.
IoT-компонент системи розробляється з використанням C++ для програмування мікроконтролерів, які керують датчиками та пристроями годування. Взаємодія між сервером та IoT-пристроями відбувається за допомогою технології WebSockets, що забезпечує двонаправлений зв'язок у реальному часі та ефективне використання мережевих ресурсів.

2	АНАЛІЗ ВИМОГ ТА СПЕЦИФІКАЦІЯ СИСТЕМИ


На основі проведеного аналізу предметної області, визначено, що метою проекту є створення програмної системи "FinFare" для автоматизації управління аквакультурою. База даних системи повинна містити інформацію про компанії, користувачів, акваріуми, види риб, параметри води, графіки годування, IoT-пристрої та їх налаштування.


2.1	Типи користувачів та їх функціонал

Система передбачає наступні типи користувачів та їх функціонал:


2.1.1	Зареєстрований користувач:

а) реєстрація та авторизація в системі;
б) перегляд списку компаній, в яких він бере участь або якими володіє;
в) створення нової компанії (автоматично стає її власником);
г) приєднання до існуючої компанії за запрошенням.

2.1.2	Власник компанії:

а) повний доступ до всіх функцій управління компанією;
б) додавання нових користувачів до компанії та призначення їм ролей;
в) налаштування параметрів компанії;
г) управління всіма акваріумами та IoT-пристроями компанії;
д) перегляд повної аналітики та звітів по компанії;
е) налаштування автоматизації процесів;

2.1.3	Користувач за призначеною роллю в компанії:

а) доступ до функцій відповідно до призначеної ролі (сфери відповідальності);
б) моніторинг параметрів води в дозволених акваріумах;
в) керування годуванням в межах своїх повноважень;

2.2	Загальний функціонал системи:

а) моніторинг параметрів води в реальному часі (кисень, температура, pH, солоність);
б) налаштування автоматичного годування риб;
в) ручне керування годуванням через веб-інтерфейс;
г) управління IoT-пристроями (датчики, годівниці);
д) генерація звітів та аналітика щодо стану акваріумів та ефективності догляду за рибами.

3	ПРОЕКТУВАННЯ БАЗИ ДАНИХ СИСТЕМИ
3.1	Розробка ER-діаграми


Для проєктування бази даних системи "FinFare" було розроблено ER-модель даних, яка відображає всі необхідні сутності та зв'язки між ними. ER-діаграма представлена на рисунку 3.1.

Рисунок 3.1 – ER-діаграма системи "FinFare"

3.2	Опис сутностей, їх полів та взаємозв'язків


а) User (Користувач):

id: унікальний ідентифікатор користувача
firebase_uid: унікальний ідентифікатор користувача в Firebase
email: електронна пошта користувача
status: статус користувача (активний, неактивний, заблокований)
created_at: дата та час створення облікового запису
updated_at: дата та час останнього оновлення

б) Company (Компанія):

id: унікальний ідентифікатор компанії
name: назва компанії
description: опис компанії
created_at: дата та час створення
updated_at: дата та час останнього оновлення

в) Aquarium (Акваріум):

id: унікальний ідентифікатор акваріума
name: назва акваріума
capacity: об'єм акваріума в літрах
description: опис акваріума
company_id: ідентифікатор компанії, якій належить акваріум
created_at: дата та час створення
updated_at: дата та час останнього оновлення

г) Fish (Риба):

id: унікальний ідентифікатор запису про рибу
species: вид риби
quantity: кількість риб даного виду
aquarium_id: ідентифікатор акваріума, в якому знаходиться риба

д) WaterParameter (Параметри води):

id: унікальний ідентифікатор запису вимірювання
ph: рівень pH води
temperature: температура води
salinity: рівень солоності води
oxygen_level: рівень кисню у воді
measured_at: дата та час вимірювання
aquarium_id: ідентифікатор акваріума

е) FeedingSchedule (Графік годування):

id: унікальний ідентифікатор запису графіка
food_type: тип корму
scheduled_time: запланований час годування
aquarium_id: ідентифікатор акваріума

є) IoTDevice (IoT-пристрій):

id: унікальний ідентифікатор пристрою
unique_address: унікальна адреса пристрою
aquarium_id: ідентифікатор акваріума, до якого прив'язаний пристрій
is_active: статус активності пристрою

ж) FoodPatch (Порція корму):

id: унікальний ідентифікатор порції корму
name: назва порції
food_type: тип корму
quantity: кількість корму в грамах
iot_device_id: ідентифікатор IoT-пристрою, до якого прив'язана порція

з) Role (Роль):

id: унікальний ідентифікатор ролі
name: назва ролі
description: опис ролі
permissions: масив дозволів, пов'язаних з роллю
company_id: ідентифікатор компанії, до якої належить роль

и) user_companies (зв'язок між користувачами та компаніями):

user_id: зовнішній ключ, що посилається на User
company_id: зовнішній ключ, що посилається на Company
role_id: зовнішній ключ, що посилається на Role

3.3	Опис зв’язків між сутностями


User - Company: "багато-до-багатьох" через проміжну таблицю user_companies
Один користувач може бути пов'язаний з багатьма компаніями
Одна компанія може мати багато користувачів


Company - Role: "один-до-багатьох"
Одна компанія може мати багато ролей
Кожна роль належить тільки одній компанії


Company - Aquarium: "один-до-багатьох"
Одна компанія може мати багато акваріумів
Кожен акваріум належить тільки одній компанії


Aquarium - Fish: "один-до-багатьох"
Один акваріум може містити багато видів риб
Кожен запис про рибу належить тільки одному акваріуму


Aquarium - WaterParameter: "один-до-багатьох"
Один акваріум може мати багато записів про параметри води
Кожен запис параметрів води належить тільки одному акваріуму


Aquarium - FeedingSchedule: "один-до-багатьох"
Один акваріум може мати багато записів графіку годування
Кожен запис графіку годування належить тільки одному акваріуму


Aquarium - IoTDevice: "один-до-одного"
Один акваріум пов'язаний з одним IoT-пристроєм
Один IoT-пристрій пов'язаний з одним акваріумом


IoTDevice - FoodPatch: "один-до-багатьох"
Один IoT-пристрій може мати багато порцій корму
Кожна порція корму належить тільки одному IoT-пристрою

4	АРХІТЕКТУРА ПРОГРАМНОЇ СИСТЕМИ
4.1	Загальна архітектура системи


Програмна система FinFare є інноваційним рішенням для централізованого управління процесами в акваріумістиці. Архітектура системи базується на сучасній багатокомпонентній структурі, що забезпечує ефективну взаємодію між різними частинами системи. Їх взаємодію та самі складові можна побачити на рисунку 4.1


Рисунок 4.1 - UML діаграма розгортання системи "FinFare"

Система складається з трьох основних компонентів:
1)	Серверна частина (Backend)
2)	Клієнтська частина (Frontend)
3)	IoT-компонент
Взаємодія між компонентами здійснюється за допомогою REST API для стандартних операцій та WebSocket протоколу для забезпечення зв'язку в реальному часі з IoT пристроями. Така архітектура дозволяє ефективно розподілити навантаження між різними компонентами системи, забезпечуючи високу продуктивність та відмовостійкість.
Система використовує гібридну модель зберігання даних. Інформація, що стосується компаній та пов'язаних з ними даних, зберігається на єдиному сервері PostgreSQL. Натомість, дані користувачів, включаючи електронні адреси та паролі, розміщуються в хмарному середовищі Firebase. Такий підхід до архітектури зберігання даних обумовлений низкою факторів: обмеженість ресурсів серверу бази даних, необхідність оптимізації запитів та підвищення продуктивності системи, прагнення спростити логіку аутентифікації та авторизації, а також ефективне використання доступного дискового простору.
Ця гібридна модель дозволяє системі FinFare забезпечити оптимальний баланс між продуктивністю, безпекою та ефективністю використання ресурсів, що є критичним для забезпечення надійного функціонування платформи управління акваріумістикою.


4.2	Архітектура серверної частини


Серверна частина системи FinFare побудована на основі монолітної архітектури, що забезпечує чітке розділення відповідальності між різними компонентами системи в рамках єдиного застосунку. Вибір монолітної архітектури обумовлений потребою в швидкій розробці, простоті розгортання та обслуговування, а також відсутністю необхідності в складній міжсервісній комунікації на даному етапі розвитку проекту.
Ця монолітна архітектура складається з наступних шарів:

1)	Шар уявлення (API endpoints): Реалізований за допомогою фреймворку FastAPI, цей шар відповідає за обробку HTTP-запитів та формування відповідей. Він забезпечує RESTful API інтерфейс для взаємодії з клієнтською частиною та IoT пристроями.
2)	Шар бізнес-логіки (Services): Цей шар містить основну логіку системи, реалізовану у вигляді сервісів. Кожен сервіс відповідає за певний домен системи (наприклад, управління компаніями, акваріумами, годуванням тощо).
3)	Шар доступу до даних (Data Access Layer): Реалізований за допомогою ORM технології SQLAlchemy, цей шар забезпечує взаємодію з базою даних PostgreSQL. Він абстрагує роботу з базою даних, дозволяючи працювати з об'єктами Python замість прямих SQL-запитів.

Архітектура серверної частини також включає наступні ключові компоненти:

1)	Dependency Injection: Використовується для управління залежностями між компонентами, що полегшує тестування та підтримку коду.
2)	Система авторизації та аутентифікації: Реалізована з використанням JWT токенів та інтеграції з Firebase Authentication.
3)	WebSocket Handler: Забезпечує двонаправлений зв'язок у реальному часі з IoT пристроями.
4)	Scheduler: Використовується для виконання періодичних завдань, таких як автоматичне годування.

Незважаючи на монолітну структуру, архітектура розроблена з урахуванням можливого майбутнього переходу на мікросервісну архітектуру. Кожен функціональний модуль (наприклад, управління компаніями, акваріумами, годуванням) розроблений з мінімальними залежностями від інших модулів, що спростить потенційне розділення на окремі мікросервіси у майбутньому, якщо виникне така необхідність.

4.2.1	Специфікація REST API


У таблиці 4.1 детально описані основні кінцеві точки API, пов'язані з ключовими функціональними можливостями програмної системи FinFare. Структура URL-адрес використовує відповідні HTTP-запити, контролери та ідентифікатори. Усі ресурси підтримують операції CRUD (Створення, Читання, Оновлення та Видалення) за допомогою відповідних методів HTTP. Деякі кінцеві точки пропонують функціональні можливості для специфічних операцій, таких як активація пристроїв чи керування годуванням.

Таблиця 4.2 – Специфікація REST API серверу «FinFare»
Сутність	Метод	Посилання	Дія
Авторизація	POST	/api/auth/register	Реєстрація нового користувача
		/api/auth/login	Вхід користувача до системи
	GET	/api/auth/me	Отримання даних користувача
	PUT	/api/auth/me	Оновлення даних користувача
	DELETE	/api/auth/me	Видалення профілю користувача
Компанії

 Компанії	POST

POST	/api/companies	Створення компанії в системі
		/api/companies/{company_id}/users	Додавання користувача до компанії
		/api/companies/{company_id}/aquariums	Створення нового акваріума в компанії
	GET	/api/companies	Отримання компаній користувача
		/api/companies/{company_id}	Отримання компанії користувача
		/api/companies/{company_id}/aquariums	Отримання списку акваріумів компанії
		/api/companies/{company_id}/users
	Отримання всіх користувачів компанії
	PUT	/api/companies/{company_id}	Оновлення компанії
	DELETE	/api/companies/{company_id}	Видалення компанії
		/api/companies{company_id}/users/{email}	Видалення користувача з компанії
Пристрої	POST	/api/devices/{aquarium_id}	Встановлення нового пристрою до акваріуму
		/api/devices/{aquarium_id}/activate	Актівація пристрою прив’язаного до акваріуму
		/api/devices/{aquarium_id}/deactivate	Деактівація пристрою прив’язаного до акваріуму
		/api/devices/{aquarium_id}/food-patch	Наповнення порції для пристрою акваріуму
	GET	/api/devices/{aquarium_id}	Отримання інформації про пристрій прив’язаний до акваріуму
	PUT	/api/devices/{aquarium_id}	Оновлення інформації про пристрій прив’язаний до акваріуму
Пристрої	DELETE	/api/devices/{aquarium_id}	Видалення пристрою прив’язаного до акваріуму
		/api/devices/{aquarium_id}/food-patch	Видалення порції для пристрою акваріума
Риби	POST	/api/aquariums/{aquarium_id}/fish	Додавання нових риб в акваріум
	GET	/api/aquariums/{aquarium_id}/fish	Отримання списку риб в акваріумі
		/api/aquariums/{aquarium_id}/fish/{fish_id}	Отримання інформації про конкретну рибу
	PUT	/api/aquariums/{aquarium_id}/fish/{fish_id}	Оновлення інформації про рибу
	DELETE	/api/aquariums/{aquarium_id}/fish/{fish_id}	Видалення риб з акваріума
Годування акваріумів	POST	/api/aquariums/{aquarium_id}/feeding-schedules	Створення розкладу годування
		/api/aquariums/{aquarium_id}/feed-now	Негайне годування
Годування акваріумів	GET	/api/aquariums/{aquarium_id}/feeding-schedules	Отримання розкладів годування акваріума
		/api/aquariums/{aquarium_id/water-parameters	Отримання параметрів мікроклімату акваріума
Ролі	POST	/api/roles/company/{company_id}	Створення ролі
		/api/roles/{role_id}/assign
	Призначення ролі користувачу
	GET	/api/roles/company/{company_id}	Отримання ролей компанії
		/api/company/{company_id}/role/{role_id}	Отримання ролі компанії
	PUT	/api/company/{company_id}/role/{role_id}	Оновлення ролі


4.3	Архітектура клієнтської частини


Клієнтська частина FinFare реалізована на React з використанням компонентного підходу. Основу інтерфейсу складають компоненти Material-UI (MUI), що забезпечують уніфікований дизайн та адаптивність. Для управління станом застосовуються два контексти React: один для зберігання даних авторизованого користувача, інший для глобальних налаштувань системи. Це дозволяє ефективно передавати дані між компонентами без надмірного використання пропсів. Взаємодія з сервером відбувається через бібліотеку Axios, яка надає зручний інтерфейс для HTTP-запитів. Axios використовується для широкого спектру взаємодій: від базових CRUD-операцій до складних запитів, таких як активація/деактивація IoT-пристроїв, ініціювання негайного годування, отримання аналітичних даних про стан акваріумів та параметри води за певний період. Для роботи з датами та часом застосовується бібліотека date-fns, що дозволяє ефективно маніпулювати та форматувати часові дані, особливо при роботі з розкладами годування та аналізом історичних даних параметрів води. Маршрутизація реалізована за допомогою React Router, що забезпечує навігацію між різними сторінками застосунку. Структура додатку включає LandingPage для неавторизованих користувачів та адміністративну панель для авторизованих. Ключові компоненти адмінпанелі включають сторінки управління компаніями, акваріумами, розкладами годування та моніторингу параметрів води. Система авторизації інтегрована з Firebase Authentication та використовує JWT токени. Для локалізації використовується react-intl, що забезпечує підтримку української та англійської мов інтерфейсу.
Для візуалізації архітектури клієнтської частини було розроблено діаграму компонентів (рис. 4.3).

Рисунок 4.3 – Діаграма компонентів web застосунку

4.4	Архітектура IoT-компоненту


IoT-компонент системи FinFare, ключовий елемент автоматизації догляду за акваріумами, розроблений на базі мікроконтролера ESP32, симульованого в середовищі Wokwi, з використанням Arduino фреймворку. Система включає датчик DHT22 для вимірювання температури та вологості, сервопривід для автоматизованого годування риб, LCD дисплей 1602 для відображення поточних параметрів акваріума, та потенціометри з ручками для симуляції датчиків солоності, pH та рівня кисню, які відсутні в симуляторі Wokwi. Ці компоненти дозволяють калібрувати та змінювати показники вручну для тестування системи. Комунікація між IoT-пристроєм та сервером здійснюється через WebSocket протокол, забезпечуючи двосторонній зв'язок у реальному часі для ефективної передачі даних про стан акваріума та отримання команд управління. IoT-пристрій виконує регулярне вимірювання параметрів води, відправку даних на сервер, виконання отриманих команд, відображення параметрів на LCD дисплеї та автоматичне годування риб за встановленим розкладом. Для візуалізації роботи IoT-компоненту було розроблено UML діаграму активності на рисунку в додатку Г, яка відображає основні процеси роботи пристрою, включаючи ініціалізацію, підключення до Wi-Fi, встановлення WebSocket з'єднання, цикл вимірювання та відправки даних, а також обробку команд від сервера.


4.5	Взаємодія користувачів з системою


Система FinFare розроблена з урахуванням потреб різних типів користувачів, кожен з яких має свій унікальний набір функцій та рівень доступу. Для наочного представлення взаємодії користувачів з системою було розроблено діаграму прецедентів (рис. 4.4).

Рисунок 4.4 – Діаграма прецедентів системи FinFare

Діаграма демонструє основні функції системи та їх доступність для різних типів користувачів:
1) Власник компанії: має можливості управління компанією (створення, редагування та видалення компанії), управління користувачами (додавання нових працівників, призначення ролей), перегляду загальної статистики та аналітики по всіх акваріумах компанії, а також налаштування глобальних параметрів системи;
2) Менеджер акваріумів: відповідає за керування IoT пристроями (додавання, налаштування та моніторинг стану пристроїв), управління акваріумами (створення нових акваріумів, налаштування параметрів), моніторинг параметрів води (перегляд поточних та історичних даних про стан води), налаштування годування (створення та редагування розкладів годування), а також керування рибами (додавання інформації про види риб та їх кількість в акваріумах);
3) Працівник з догляду: має можливості виконання завдань з годування (включаючи ініціювання позапланового годування), моніторингу параметрів (перегляд поточного стану акваріумів), а також реєстрації виконаних робіт (внесення інформації про проведені процедури догляду);
4) IoT пристрій: здійснює автоматичне вимірювання параметрів води (регулярний збір даних про температуру, pH, рівень кисню тощо), виконання годування за розкладом (автоматична подача корму у визначений час), а також відправку даних на сервер (регулярна передача зібраної інформації для аналізу). Така структура взаємодії користувачів з системою забезпечує ефективне управління акваріумами на всіх рівнях: від стратегічного управління компанією до щоденного догляду за рибами, при цьому автоматизуючи рутинні процеси за допомогою IoT технологій.

5	ОПИС ІНТЕРФЕЙСУ ТА ФУНКЦІОНАЛЬНОСТІ СИСТЕМИ
5.1	Вхід до системи


Для початку роботи з веб-застосунком FinFare користувачу необхідно увійти в систему. Процес входу включає наступні кроки:
1) 	На головній сторінці натиснути кнопку "Увійти" у правому верхньому куті екрану.
2)	 У модальному вікні, що з'явилося, ввести свою електронну пошту та пароль.
3)	 Натиснути кнопку "Увійти" для підтвердження.
Якщо у користувача ще немає облікового запису, він може зареєструватися, натиснувши на посилання "Немає акаунту? Зареєструватися" під формою входу.

Рисунок 5.1 - Форма входу до системи

5.2	Вибір компанії


Після успішної авторизації користувач потрапляє на головну сторінку системи. Для початку роботи необхідно вибрати компанію:
1) 	Натиснути кнопку "Компанія" у правому верхньому куті екрану.
2.)	У випадаючому меню вибрати "Мої компанії" для вибору існуючої компанії або "Створити компанію" для створення нової.
Якщо компанія не вибрана, користувач побачить повідомлення "Компанію не вибрано" та інструкцію щодо вибору компанії.

Рисунок 5.2 - Екран при невибраній компанії

5.3	Створення нової компанії


Для створення нової компанії необхідно:
1) 	Натиснути "Створити компанію" у випадаючому меню.
2) 	У модальному вікні, що з'явилося, ввести назву компанії та її опис.
3)	 Натиснути кнопку "Створити компанію" для підтвердження.

Рисунок 5.3 - Модальне вікно створення нової компанії

5.4	Навігація по системі


Після успішного входу в профіль користувач отримує доступ до основного функціоналу системи. Навігація здійснюється за допомогою меню у верхній частині сторінки, яке містить наступні розділи:
-	Акваріуми
-	Пристрої
-	Годівниці
-	Управління компанією
-	Профіль
Для переходу до потрібного розділу достатньо натиснути на відповідний пункт меню.


5.5	Управління акваріумами


При переході до розділу "Акваріуми" користувач бачить список всіх акваріумів компанії.

Рисунок 5.5 - Екран управління акваріумами
На цьому екрані користувач може:

1) Створити новий акваріум, натиснувши кнопку "Створити акваріум".
2) Переглядати інформацію про кожен акваріум, включаючи назву, об'єм та список риб.
3) Редагувати інформацію про акваріум, натиснувши кнопку "Редагувати" на картці акваріума.
4) Додавати нових риб до акваріума, використовуючи кнопку "Додати рибу".
5) Редагувати або видаляти інформацію про риб за допомогою відповідних іконок.
6) Годувати риб (якщо до акваріума підключений пристрій) за допомогою кнопки "Погодувати".
7) Видалити акваріум, натиснувши кнопку "Видалити".


5.6	Управління пристроями


У розділі "Пристрої" користувач може керувати IoT-пристроями, підключеними до акваріумів.

Рисунок 5.6.1 – Екран управління пристроями

На цьому екрані доступні наступні функції:

1)	Додавання нового пристрою за допомогою кнопки "Додати пристрій".
2)	Перегляд списку всіх пристроїв з інформацією про їх статус та прив'язку до акваріумів.
3)	Редагування інформації про пристрій (кнопка "Редагувати").
4)	Активація або деактивація пристрою однією кнопкою.
5)	Керування кормом: при натисканні на "Керувати кормом" відкривається модальне вікно, де можна додати порцію корму для подальшого годування.
6)	Детальний перегляд параметрів мікроклімату: кожна картка пристрою є клікабельною. При натисканні на картку відкривається вікно з детальною інформацією про параметри води за вибраний період.

Рисунок 5.6.2 - Модальне вікно додавання порції корму

Вибирати можна кілкість а все інше можна писати будь-яке. Відповідальність за це несе користувач призначений власником компанії.


Рисунок 5.6.3 - Екран детального перегляду параметрів мікроклімату

На екрані детального перегляду параметрів мікроклімату користувач може:
1)	Бачити адресу пристрою та його поточний статус.
2)	Вибирати діапазон дат для перегляду даних.
3)	Переглядати таблицю з історією вимірювань, яка включає дату та час вимірювання, pH, температуру, солоність та рівень кисню.
4)	Аналізувати зміни параметрів води в часі для оцінки стану акваріума та планування необхідних дій з догляду.
Ця функція дозволяє користувачам отримувати детальну інформацію про стан води в акваріумі за певний період, що є критично важливим для підтримки здорового середовища для риб та інших водних мешканців.


5.7	Управління годівницями


Розділ "Годівниці" дозволяє налаштувати автоматичне годування риб за розкладом.

Рисунок 5.7.1 - Екран управління годівницями
На цьому екрані користувач може:
1)	Вибрати акваріум зі списку для налаштування годування.
2)	Переглядати існуючі розклади годування.
3)	Додавати новий розклад годування, натиснувши кнопку "Додати розклад годування".
4)	Редагувати або видаляти існуючі розклади.
При додаванні або редагуванні розкладу годування відкривається модальне вікно, де можна вказати тип корму та запланований час годування.

Рисунок 5.7.2 - Модальне вікно додавання розкладу годування

Годування проходитиме надто точно, затримка може бути не більше хвилини.


5.8	Управління компанією


Розділ "Управління компанією" містить три вкладки для більш детального керування:

Рисунок 5.8.1- Вкладка «інформація про компанію»

Інформація про компанію включає в себе наступні функції:
1)	Перегляд та редагування назви компанії
2)	Зміна опису компанії
3)	Оновлення або видалення компанії

Рисунок 5.8.2 – Вкладка «Ролі»

Вкладка ролі включає в себе наступні функції:
1)	Створення нових ролей за допомогою кнопки "Створити роль"
2)	Перегляд існуючих ролей
3)	Редагування назв та описів ролей

Рисунок 5.8.3 - Модальне вікно створення нової ролі

Для створення нової ролі необхідно:

1)	Натиснути кнопку "Створити роль".
2)	У модальному вікні ввести назву ролі та її опис.
3)	Вибрати дозволи для нової ролі, встановивши відповідні прапорці:
-	Керувати пристроями
-	Переглядати компанію
-	Керувати акваріумами
-	Керувати годівницями
4)	Натиснути кнопку "Зберегти" для створення ролі або "Скасувати" для відміни операції.

Рисунок 5.8.4 – Вкладка «Користувачі»

Вкладка користувачі включає в себе наступні функції:
1)	Додавання нових користувачів до компанії
2)	Перегляд списку всіх користувачів компанії
3)	Зміна ролей користувачів за допомогою випадаючого меню
4)	Видалення користувачів з компанії

5.9	Профіль користувача


У розділі "Профіль" користувач має доступ до особистої інформації та налаштувань акаунту.

Рисунок 5.9 - Екран профілю користувача

На цьому екрані користувач може:
1)	Переглядати та редагувати особисту інформацію, включаючи ім'я для відображення, електронну пошту та номер телефону.
2)	Оновлювати профіль, натиснувши кнопку "Оновити профіль".
3)	Переглядати інформацію про акаунт, таку як ID користувача, статус та дата створення.
4)	За необхідності видалити свій акаунт, натиснувши кнопку "Видалити акаунт".

5.10	Зміна мови інтерфейсу


Для зміни мови сайту FinFare користувач може скористатися функцією перемикання мови, розташованою у правому верхньому куті сторінки. Ця функція представлена у вигляді іконки прапора.
Щоб змінити мову інтерфейсу:
1)	Знайдіть іконку прапора у правому верхньому куті сторінки.
2)	Натисніть на неї, щоб відкрити випадаюче меню з доступними мовами.
3)	Виберіть бажану мову зі списку.
Після вибору мови, інтерфейс сайту автоматично оновиться, і всі елементи будуть відображені вибраною мовою.

Рисунок 5.10 - Приклад зміни мови інтерфейсу на лендінгу

Ця функція забезпечує зручність використання сайту для користувачів з різних країн, дозволяючи їм працювати з системою FinFare рідною мовою.

ВИСНОВКИ


В результаті виконання курсової роботи було створено програмну систему "FinFare" для автоматизації управління акваріумами та догляду за рибами. Система розроблена з використанням сучасних технологій, включаючи React для веб-інтерфейсу, FastAPI для серверної частини на Python, та C++ для IoT-компонентів. База даних реалізована на PostgreSQL, що забезпечує надійне зберігання та швидкий доступ до даних.
Система "FinFare" надає комплексне рішення для управління акваріумними господарствами, включаючи моніторинг параметрів води (температура, pH, рівень кисню, солоність) в реальному часі, автоматизоване годування риб, та гнучке управління користувачами через систему ролей. Веб-інтерфейс системи розроблений з урахуванням принципів user-friendly дизайну та адаптивності, що дозволяє зручно працювати на різних пристроях, починаючи з телефону і закінчуючи телевізором.
Інтеграція з IoT-пристроями забезпечує автоматичний збір даних та виконання команд, таких як годування риб за розкладом. Реалізована функціональність створення та управління компаніями дозволяє використовувати систему як для невеликих домашніх акваріумів, так і для великих комерційних акваріумних господарств. Система підтримує багатомовний інтерфейс, що розширює її доступність для користувачів з різних країн.
В цілому, створена програмна система "FinFare" є ефективним інструментом для оптимізації процесів догляду за акваріумами, що може значно підвищити якість утримання риб та ефективність роботи акваріумних господарств різного масштабу.

ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ


1.	Material-UI Blog: Insights and Updates. URL: https://mui.com/blog/ (дата звернення: 12.07.2024).
2.	React Patterns: A collection of design patterns/techniques used while developing with React. URL: https://github.com/reactpatterns/reactpatterns (дата звернення: 8.07.2024).
3.	IoT For All: Internet of Things (IoT) News, Resources, and Thought Leadership. URL: https://www.iotforall.com/ (дата звернення: 2.08.2024).
4.	Kurniawan A. ESP32 Internet of Things Projects: Build modern IoT solutions with the ESP32. Packt Publishing, 2021. 374 p.
5.	Посилання на відео обзор курсової роботи: …

ДОДАТОК А
Код серверної частини системи

А.1 частина коду бізнес-логіки годівниці

1 class DeviceFeedingService:
2     def __init__(self, db: Session, connection_manager: ConnectionManager):
3         self.db = db
4         self.connection_manager = connection_manager
5
6     def setup_device(self, aquarium_id: int, device_data: IoTDeviceCreate) -> IoTDevice:
7         aquarium = self.db.query(Aquarium).filter(Aquarium.id == aquarium_id).first()
8         if not aquarium:
9             raise ValueError(f"Акваріум з id {aquarium_id} не знайдено")
10
11         existing_device = self.db.query(IoTDevice).filter(
12             IoTDevice.unique_address == device_data.unique_address).first()
13         if existing_device:
14             raise ValueError(f"Пристрій з адресою {device_data.unique_address} вже існує")
15
16         existing_aquarium_device = self.db.query(IoTDevice).filter(
17             IoTDevice.aquarium_id == aquarium_id).first()
18         if existing_aquarium_device:
19             raise ValueError(f"Акваріум з id {aquarium_id} вже має пристрій")
20
21         new_device = IoTDevice(
22             unique_address=device_data.unique_address,
23             aquarium_id=aquarium_id,
24             is_active=True
25         )
26         self.db.add(new_device)
27         self.db.commit()
28         self.db.refresh(new_device)
29
30         logger.info(f"Новий пристрій успішно встановлено для акваріума {aquarium_id}")
31         return new_device
32
33     def get_aquarium(self, aquarium_id: int) -> Aquarium:
34         aquarium = self.db.query(Aquarium).filter(Aquarium.id == aquarium_id).first()
35         if not aquarium:
36             raise ValueError(f"Акваріум з id {aquarium_id} не знайдено")
37         return aquarium
38
39     def get_aquarium_device(self, aquarium_id: int) -> IoTDevice:
40         device = self.db.query(IoTDevice).filter(IoTDevice.aquarium_id == aquarium_id).first()
41         if not device:
42             raise ValueError(f"IoT пристрій не знайдено для акваріума {aquarium_id}")
43         return device
44
45     def update_device(self, aquarium_id: int, device_data: IoTDeviceUpdate) -> IoTDevice:
46         device = self.get_aquarium_device(aquarium_id)
47         if not device:
48             raise ValueError(f"IoT пристрій не знайдено для акваріума {aquarium_id}")
49
50         for key, value in device_data.dict(exclude_unset=True).items():
51             setattr(device, key, value)
52
53         try:
54             self.db.commit()
55             self.db.refresh(device)
56         except Exception as e:
57             self.db.rollback()
58             raise ValueError(f"Помилка при оновленні пристрою: {str(e)}")
59
60         return device
61
62     async def activate_device(self, device_id: int) -> IoTDevice:
63         device = self.db.query(IoTDevice).filter(IoTDevice.id == device_id).first()
64         if not device:
65             raise ValueError(f"IoT пристрій з id {device_id} не знайдено")
66
67         logger.info(f"Спроба активувати пристрій {device.unique_address}")
68
69         try:
70             device.is_active = True
71             self.db.commit()
72
73             if device.unique_address in self.connection_manager.active_connections:
74                 await self.connection_manager.send_command(device.unique_address, {"action": "activate"})
75             else:
76                 logger.warning(f"Пристрій {device.unique_address} не підключений по WebSocket")
77         except Exception as e:
78             logger.exception(f"Помилка при активації пристрою {device_id}: {str(e)}")
79             self.db.rollback()
80             raise
81
82         return device
83
84     async def deactivate_device(self, device_id: int) -> IoTDevice:
85         device = self.db.query(IoTDevice).filter(IoTDevice.id == device_id).first()
86         if not device:
87             raise ValueError(f"IoT пристрій з id {device_id} не знайдено")
88
89         try:
90             device.is_active = False
91             self.db.commit()
92
93             if device.unique_address in self.connection_manager.active_connections:
94                 await self.connection_manager.send_command(device.unique_address, {"action": "deactivate"})
95             else:
96                 logger.warning(f"Пристрій {device.unique_address} не підключений по WebSocket")
97         except Exception as e:
98             logger.exception(f"Помилка при деактивації пристрою {device_id}: {str(e)}")
99             self.db.rollback()
100             raise
101
102         return device
103
104     async def sync_device_status(self, unique_address: str):
105         device = self.get_device_by_address(unique_address)
106         if device:
107             action = "activate" if device.is_active else "deactivate"
108             await self.connection_manager.send_command(unique_address, {"action": action})
109         else:
110             logger.warning(f"Пристрій {unique_address} не знайдено при спробі синхронізації статусу")
111
112     async def handle_device_identification(self, unique_address: str):
113         device = self.get_device_by_address(unique_address)
114         if device:
115             await self.connection_manager.send_command(unique_address, {
116                 "action": "status_update",
117                 "is_active": device.is_active
118             })
119         else:
120             logger.warning(f"Пристрій {unique_address} не знайдено в базі даних")
121
122     def add_feeding_schedule(self, aquarium_id, schedule_data: FeedingScheduleCreate) -> FeedingSchedule:
123         self.get_aquarium_device(aquarium_id)
124
125         new_schedule = FeedingSchedule(
126             food_type=schedule_data.food_type,
127             scheduled_time=schedule_data.scheduled_time,
128             aquarium_id=aquarium_id
129         )
130         self.db.add(new_schedule)
131         self.db.commit()
132         self.db.refresh(new_schedule)
133         return new_schedule
134
135     def get_aquarium_feeding_schedules(self, aquarium_id: int) -> List[FeedingSchedule]:
136         schedules = self.db.query(FeedingSchedule).filter(FeedingSchedule.aquarium_id == aquarium_id).all()
137         return schedules
138
139     def get_feeding_schedule(self, schedule_id: int) -> FeedingSchedule:
140         schedule = self.db.query(FeedingSchedule).filter(FeedingSchedule.id == schedule_id).first()
141         if not schedule:
142             raise ValueError("Розклад годування не знайдено")
143         return schedule
144
145     def update_feeding_schedule(self, schedule_id: int, schedule_data: FeedingScheduleUpdate) -> FeedingSchedule:
146         schedule = self.get_feeding_schedule(schedule_id)
147         for key, value in schedule_data.dict(exclude_unset=True).items():
148             setattr(schedule, key, value)
149         self.db.commit()
150         self.db.refresh(schedule)
151         return schedule
152
153     def delete_feeding_schedule(self, schedule_id: int):
154         schedule = self.get_feeding_schedule(schedule_id)
155         self.db.delete(schedule)
156         self.db.commit()
157
158     async def send_feed_command(self, device_address: str, food_type: str, quantity: int):
159         try:
160             await self.connection_manager.send_command(device_address, {
161                 "action": "feed",
162                 "food_type": food_type,
163                 "quantity": quantity,
164                 "duration": 1.0  # Тривалість годування в секундах сервоприводу
165             })
166         except Exception as e:
167             logger.error(f"Помилка при відправці команди на годування: {str(e)}")
168             raise
169
170     async def feed_now(self, aquarium_id: int) -> dict:
171         device = self.get_aquarium_device(aquarium_id)
172         if not device.is_active:
173             return {"status": "error", "message": "Пристрій деактивовано"}
174
175         food_patch = self.db.query(FoodPatch).filter(
176             FoodPatch.iot_device_id == device.id, FoodPatch.quantity > 0
177         ).first()
178         if not food_patch:
179             return {"status": "error", "message": "Порцію корму не знайдено або він закінчився"}
180
181         try:
182             await self.send_feed_command(device.unique_address, food_patch.food_type, 1)
183
184             # Зменшуємо кількість корму в патчі тільки якщо команда відправлена успішно
185             food_patch.quantity -= 1
186             self.db.commit()
187
188             return {"status": "success", "message": "Команда на годування відправлена"}
189         except Exception as e:
190             return {"status": "error", "message": f"Помилка при відправці команди на годування: {str(e)}"}
191
192     async def auto_feed(self):
193         current_time = datetime.now().time()
194         one_minute_ago = (datetime.now() - timedelta(minutes=1)).time()
195         schedules = self.db.query(FeedingSchedule).filter(
196             and_(
197                 FeedingSchedule.scheduled_time >= one_minute_ago,
198                 FeedingSchedule.scheduled_time <= current_time
199             )
200         ).all()
201
202         for schedule in schedules:
203             result = await self.feed_now(schedule.aquarium_id)
204             if result["status"] == "error":
205                 logger.warning(
206                     f"Помилка при автоматичному годуванні для акваріума {schedule.aquarium_id}: {result['message']}")
207             else:
208                 logger.info(f"Команда на автоматичне годування відправлена для акваріума {schedule.aquarium_id}")
209
210             # Обновляем время последнего кормления независимо от результата
211             schedule.last_feed_time = datetime.now().time()
212             self.db.commit()
213
214     async def handle_feed_result(self, device_id: str, success: bool):
215         device = self.db.query(IoTDevice).filter(IoTDevice.unique_address == device_id).first()
216         if not device:
217             logger.error(f"Пристрій {device_id} не знайдено")
218             return
219
220         if success:
221             logger.info(f"Годування успішно виконано пристроєм {device_id}")
222             # На майбутнє можливо додам логіку для оновлення стану прострою або запису результату годування
223         else:
224             logger.error(f"Помилка при годуванні пристроєм {device_id}")
225             # На майбутнє можливу додам логіку для обрабки помилок, наприклад, повернення корму в патч
226             food_patch = self.db.query(FoodPatch).filter(FoodPatch.iot_device_id == device.id).first()
227             if food_patch:
228                 food_patch.quantity += 1
229                 self.db.commit()
230                 logger.info(f"Кількість корму повернуто для пристрою {device_id}")
231
232     def get_device_by_address(self, unique_address: str) -> IoTDevice:
233         device = self.db.query(IoTDevice).filter(IoTDevice.unique_address == unique_address).first()
234         if not device:
235             raise ValueError(f"Пристрій з адресою {unique_address} не знайдено")
236         return device
237
238     async def save_water_parameters(self, aquarium_id: int, params: dict):
239         try:
240             water_params = WaterParameterCreate(
241                 ph=params['ph'],
242                 temperature=params['temperature'],
243                 salinity=params['salinity'],
244                 oxygen_level=params['oxygen_level'],
245                 aquarium_id=aquarium_id
246             )
247             water_param = WaterParameter(**water_params.dict())
248             self.db.add(water_param)
249             self.db.commit()
250         except Exception as e:
251             self.db.rollback()
252             logger.error(f"Помилка при збереженні параметрів води для акваріума {aquarium_id}: {str(e)}")
253             raise
254
255     def fill_food_patch(self, aquarium_id: int, food_patch_data: FoodPatchCreate) -> FoodPatch:
256         device = self.get_aquarium_device(aquarium_id)
257         if not device:
258             raise ValueError(f"Пристрій для акваріума з id {aquarium_id} не встановлено")
259
260         food_patch = FoodPatch(**food_patch_data.dict(), iot_device_id=device.id)
261
262         self.db.add(food_patch)
263         self.db.commit()
264         self.db.refresh(food_patch)
265         logger.info(f"FoodPatch для акваріума {aquarium_id} успішно створено/оновлено")
266         return food_patch
267
268     def get_food_patch(self, aquarium_id: int) -> FoodPatch:
269         device = self.get_aquarium_device(aquarium_id)
270         if not device:
271             raise ValueError(f"Пристрій для акваріума з id {aquarium_id} не встановлено")
272
273         food_patch = self.db.query(FoodPatch).filter(FoodPatch.iot_device_id == device.id).first()
274         if not food_patch:
275             raise ValueError(f"Порція для акваріума з id {aquarium_id} не знайдена")
276         return food_patch
277
278     def delete_food_patch(self, aquarium_id: int):
279         food_patch = self.get_food_patch(aquarium_id)
280         self.db.delete(food_patch)
281         self.db.commit()
282         logger.info(f"Порція для акваріума {aquarium_id} успішно видалена")
283
284     def get_water_parameters(self, aquarium_id: int, start_date: datetime, end_date: datetime) -> List[WaterParameterResponse]:
285         water_parameters = self.db.query(WaterParameter).filter(
286             and_(
287                 WaterParameter.aquarium_id == aquarium_id,
288                 WaterParameter.measured_at >= start_date,
289                 WaterParameter.measured_at <= end_date
290             )
291         ).order_by(WaterParameter.measured_at.desc()).all()
292         return [WaterParameterResponse.from_orm(param) for param in water_parameters]
293
294
295 def get_device_feeding_service(
296         db: Session = Depends(db_session),
297         connection_manager: ConnectionManager = Depends(get_connection_manager)
298 ) -> DeviceFeedingService:
299     return DeviceFeedingService(db, connection_manager)

А.2 Код головного модулю з планувальником задач та ініціалізаціями маршрутів

1 app = FastAPI(
2     title="FinFare",
3     version="1.0.0",
4     description="Програмна система для догляду за рибками",
5     debug=True
6 )
7
8 app.add_middleware(
9     CORSMiddleware,
10     allow_origins=[settings.FRONTEND_URL],
11     allow_credentials=True,
12     allow_methods=["*"],
13     allow_headers=["*"],
14 )
15
16 connection_manager = ConnectionManager()
17 scheduler = AsyncIOScheduler()
18
19
20 @app.on_event("startup")
21 async def startup():
22     setup_database()
23     scheduler.start()
24
25
26 @app.on_event("shutdown")
27 async def shutdown():
28     await teardown_database()
29     scheduler.shutdown()
30
31
32 api_router = APIRouter()
33 app.include_router(auth_router, prefix=settings.API_STR, tags=["Авторизація"])
34 app.include_router(role_router, prefix=settings.API_STR, tags=["Ролі"])
35 app.include_router(company_router, prefix=settings.API_STR, tags=["Компанії"])
36
37 app.include_router(fish_router, prefix=settings.API_STR, tags=["Риби"])
38 app.include_router(device_router, prefix=settings.API_STR, tags=["Пристрої"])
39 app.include_router(feeding_schedule_router, prefix=settings.API_STR, tags=["Розклади годування"])
40 app.include_router(aquarium_feeding_router, prefix=settings.API_STR, tags=["Годування акваріумів"])
41 app.include_router(ws_router, tags=["WebSocket"])
42
43
44 @app.exception_handler(RequestValidationError)
45 async def value_error_exception_handler(request: Request, exc: RequestValidationError):
46     error = exc.errors()[0]
47     print(error)
48     return JSONResponse(
49         status_code=400,
50         content={"detail": f"Помилка у {error['loc'][1]}, {error['msg']}"},
51     )
52
53
54 @app.get("/")
55 async def root():
56     return {"message": "Hello World"}
57
58
59 @app.get("/hello/{name}")
60 async def say_hello(name: str):
61     return {"message": f"Hello {name}"}
62
63
64 def get_device_feeding_service(db: Session = Depends(db_session)) -> DeviceFeedingService:
65     return DeviceFeedingService(db, connection_manager)
66
67
68 async def scheduled_auto_feed():
69     db = next(db_session())
70     try:
71         feeding_service = DeviceFeedingService(db, connection_manager)
72         await feeding_service.auto_feed()
73     finally:
74         db.close()
75
76
77 scheduler.add_job(
78     scheduled_auto_feed,
79     trigger=IntervalTrigger(minutes=1),
80     id='auto_feed_job',
81     replace_existing=True
82 )
83
84 if __name__ == "__main__":
85     uvicorn.run(app, host="0.0.0.0", port=8000)

А.3 Код менеджеру веб-сокет з’єднань

1 class ConnectionManager:
2     def __init__(self):
3         self.active_connections: Dict[str, WebSocket] = {}
4         self.device_statuses: Dict[str, bool] = {}
5         self.lock = asyncio.Lock()
6
7     async def connect(self, websocket: WebSocket, unique_address: str):
8         await websocket.accept()
9         async with self.lock:
10             self.active_connections[unique_address] = websocket
11         print(f"Пристрій {unique_address} підключився")
12
13     async def disconnect(self, unique_address: str):
14         async with self.lock:
15             self.active_connections.pop(unique_address, None)
16         print(f"Пристрій {unique_address} відключився")
17
18     async def send_command(self, unique_address: str, message: dict):
19         if unique_address in self.active_connections:
20             await self.active_connections[unique_address].send_json(message)
21         else:
22             raise ValueError(f"Пристрій {unique_address} не підключений")
23
24     async def broadcast(self, message: dict):
25         for connection in self.active_connections.values():
26             await connection.send_json(message)

А.4 Код http маршруту акваріумів

1 aquarium_feeding_router = APIRouter(tags=["Годування акваріумів"], prefix="/aquariums/{aquarium_id}")
2
3
4 def require_permissions(*required_permissions: str):
5     def decorator(func):
6         @wraps(func)
7         async def wrapper(
8                 *args,
9                 current_user: dict = Depends(get_current_user),
10                 role_manager: RoleManager = Depends(get_role_manager),
11                 device_service: DeviceFeedingService = Depends(get_device_feeding_service),
12                 **kwargs
13         ):
14             company_id = 0
15             aquarium_id = kwargs.get('aquarium_id')
16
17             try:
18                 device = device_service.get_aquarium_device(aquarium_id)
19                 company_id = device.aquarium.company_id
20             except ValueError:
21                 raise HTTPException(status_code=404, detail=company_id)
22
23             user_permissions = role_manager.get_user_permissions(current_user['uid'], company_id)
24
25             has_permission = role_manager.check_permissions(current_user['uid'], list(required_permissions), company_id)
26
27             if not has_permission:
28                 raise HTTPException(status_code=403, detail="Недостатньо прав для виконання цієї дії")
29
30             return await func(*args, current_user=current_user, role_manager=role_manager,
31                               device_service=device_service, **kwargs)
32
33         return wrapper
34
35     return decorator
36
37
38 @aquarium_feeding_router.post("/feeding-schedules", response_model=FeedingScheduleResponse,
39                               summary="Створення розкладу годування")
40 @require_permissions("manage_feeding_schedules")
41 async def create_feeding_schedule(
42         aquarium_id: int = Path(..., description="ID акваріума"),
43         schedule_data: FeedingScheduleCreate = ...,
44         current_user: dict = Depends(get_current_user),
45         device_service: DeviceFeedingService = Depends(get_device_feeding_service),
46         role_manager: RoleManager = Depends(get_role_manager)
47 ):
48     try:
49         new_schedule = device_service.add_feeding_schedule(aquarium_id, schedule_data)
50         return FeedingScheduleResponse.from_orm(new_schedule)
51     except ValueError as e:
52         raise HTTPException(status_code=400, detail=str(e))
53
54
55 @aquarium_feeding_router.get("/feeding-schedules", response_model=List[FeedingScheduleResponse],
56                              summary="Отримання розкладів годування акваріума")
57 @require_permissions("view_feeding_schedules")
58 async def get_feeding_schedules(
59         aquarium_id: int = Path(..., description="ID акваріума"),
60         current_user: dict = Depends(get_current_user),
61         device_service: DeviceFeedingService = Depends(get_device_feeding_service),
62         role_manager: RoleManager = Depends(get_role_manager)
63 ):
64     try:
65         schedules = device_service.get_aquarium_feeding_schedules(aquarium_id)
66         return [FeedingScheduleResponse.from_orm(schedule) for schedule in schedules]
67     except ValueError as e:
68         raise HTTPException(status_code=404, detail=str(e))
69
70
71 @aquarium_feeding_router.post("/feed-now", summary="Негайне годування")
72 @require_permissions("manage_feeding")
73 async def feed_now(
74         aquarium_id: int = Path(..., description="ID акваріума"),
75         current_user: dict = Depends(get_current_user),
76         device_service: DeviceFeedingService = Depends(get_device_feeding_service),
77         role_manager: RoleManager = Depends(get_role_manager)
78 ):
79     try:
80         result = await device_service.feed_now(aquarium_id)
81         return result
82     except ValueError as e:
83         raise HTTPException(status_code=400, detail=str(e))
84
85
86 @aquarium_feeding_router.get("/water-parameters", response_model=List[WaterParameterResponse],
87                              summary="Отримання параметрів мікроклімату акваріума")
88 @require_permissions("view_water_parameters")
89 async def get_water_parameters(
90         aquarium_id: int = Path(..., description="ID акваріума"),
91         start_date: datetime = Query(..., description="Початкова дата"),
92         end_date: datetime = Query(..., description="Кінцева дата"),
93         current_user: dict = Depends(get_current_user),
94         device_service: DeviceFeedingService = Depends(get_device_feeding_service),
95         role_manager: RoleManager = Depends(get_role_manager)
96 ):
97     try:
98         water_parameters = device_service.get_water_parameters(aquarium_id, start_date, end_date)
99         return [WaterParameterResponse.from_orm(param) for param in water_parameters]
100     except ValueError as e:
101         raise HTTPException(status_code=404, detail=str(e))

ДОДАТОК Б
Код клієнтської частини web

Б.1 – Код контексту авторизації

1 const AuthContext = createContext(null);
2
3 export const AuthProvider = ({ children }) => {
4     const [user, setUser] = useState(null);
5     const [error, setError] = useState(null);
6     const [successMessage, setSuccessMessage] = useState(null);
7     const { t } = useTranslation();
8     const navigator = useNavigate();
9
10     useEffect(() => {
11         const token = localStorage.getItem('access_token');
12         if (token) {
13             if (isTokenExpired(token)) {
14                 handleLogout();
15             } else {
16                 setUser({ token });
17             }
18         }
19
20         const handleLogoutEvent = () => {
21             handleLogout();
22         };
23
24         window.addEventListener('logout', handleLogoutEvent);
25
26         return () => {
27             window.removeEventListener('logout', handleLogoutEvent);
28         };
29     }, []);
30
31     const isTokenExpired = (token) => {
32         try {
33             const decoded = jwtDecode(token);
34             return decoded.exp < Date.now() / 1000;
35         } catch (e) {
36             return true;
37         }
38     };
39
40     const handleLogout = () => {
41         localStorage.removeItem('access_token');
42         localStorage.removeItem('token_type');
43         setUser(null);
44         setError(null);
45         window.dispatchEvent(new CustomEvent('userLoggedOut'));
46         navigator('/');
47     };
48
49     const login = async (email, password) => {
50         try {
51             const response = await authApi.login({ email, password });
52             const { access_token, token_type } = response.data;
53             localStorage.setItem('access_token', access_token);
54             localStorage.setItem('token_type', token_type);
55             setUser({ token: access_token });
56             setError(null);
57             return true;
58         } catch (err) {
59             setError(err.response?.data?.detail);
60             return false;
61         }
62     };
63
64     const register = async (email, password, displayName) => {
65         try {
66             await authApi.register({ email, password, display_name: displayName });
67             setSuccessMessage(t('registrationSuccess'));
68             setError(null);
69             return true;
70         } catch (err) {
71             setError(err.response?.data?.detail);
72             return false;
73         }
74     };
75
76     const logout = async () => {
77         try {
78             await authApi.logout();
79         } catch (err) {
80             console.error(err);
81         } finally {
82             handleLogout();
83         }
84     };
85
86     return (
87         <AuthContext.Provider value={{ user, error, successMessage, login, register, logout, setError, setSuccessMessage }}>
88             {children}
89         </AuthContext.Provider>
90     );
91 };
92
93 export const useAuth = () => useContext(AuthContext);

Б.2 Код сторінки детальніше для пристрою

1 const DeviceDetailPage = () => {
2     const { aquariumId } = useParams();
3     const navigate = useNavigate();
4     const { t } = useTranslation();
5     const [device, setDevice] = useState(null);
6     const [waterParameters, setWaterParameters] = useState([]);
7     const [loading, setLoading] = useState(true);
8     const [startDate, setStartDate] = useState(subDays(new Date(), 7));
9     const [endDate, setEndDate] = useState(new Date());
10
11     useEffect(() => {
12         fetchDeviceAndParameters();
13     }, [aquariumId, startDate, endDate]);
14
15     const fetchDeviceAndParameters = async () => {
16         setLoading(true);
17         try {
18             const deviceResponse = await deviceApi.getDevice(aquariumId);
19             setDevice(deviceResponse.data);
20
21             const parametersResponse = await deviceApi.getWaterParameters(
22                 deviceResponse.data.aquarium_id,
23                 startDate.toISOString(),
24                 endDate.toISOString()
25             );
26
27             setWaterParameters(parametersResponse.data);
28         } catch (error) {
29             console.error(error?.response?.data?.detail || error.message);
30         } finally {
31             setLoading(false);
32         }
33     };
34
35     if (loading) {
36         return (
37             <Box display="flex" justifyContent="center" alignItems="center" minHeight="100vh">
38                 <CircularProgress />
39             </Box>
40         );
41     }
42
43     if (!device) {
44         return (
45             <Container>
46                 <Typography variant="h4">{t('deviceNotFound')}</Typography>
47             </Container>
48         );
49     }
50
51     return (
52         <Container maxWidth="lg">
53             <Button
54                 startIcon={<ArrowBackIcon />}
55                 onClick={() => navigate(-1)}
56                 sx={{ mt: 2, mb: 2 }}
57             >
58                 {t('back')}
59             </Button>
60             <Paper elevation={3} sx={{ p: 3, mt: 3 }}>
61                 <Typography variant="h4" gutterBottom>{t('deviceDetails')}</Typography>
62                 <Typography variant="h6">{t('deviceAddress')}: {device.unique_address}</Typography>
63                 <Typography>{t('status')}: {device.is_active ? t('active') : t('inactive')}</Typography>
64             </Paper>
65
66             <Paper elevation={3} sx={{ mt: 3, p: 3 }}>
67                 <Typography variant="h5" gutterBottom>{t('waterParameters')}</Typography>
68                 <LocalizationProvider dateAdapter={AdapterDateFns}>
69                     <Grid container spacing={2} sx={{ mb: 3 }}>
70                         <Grid item xs={12} sm={6}>
71                             <DatePicker
72                                 label={t('startDate')}
73                                 value={startDate}
74                                 onChange={(newValue) => setStartDate(newValue)}
75                                 renderInput={(params) => <TextField {...params} fullWidth />}
76                             />
77                         </Grid>
78                         <Grid item xs={12} sm={6}>
79                             <DatePicker
80                                 label={t('endDate')}
81                                 value={endDate}
82                                 onChange={(newValue) => setEndDate(newValue)}
83                                 renderInput={(params) => <TextField {...params} fullWidth />}
84                             />
85                         </Grid>
86                     </Grid>
87                 </LocalizationProvider>
88
89                 <TableContainer>
90                     <Table>
91                         <TableHead>
92                             <TableRow>
93                                 <TableCell>{t('dateTime')}</TableCell>
94                                 <TableCell>{t('ph')}</TableCell>
95                                 <TableCell>{t('temperature')}</TableCell>
96                                 <TableCell>{t('salinity')}</TableCell>
97                                 <TableCell>{t('oxygenLevel')}</TableCell>
98                             </TableRow>
99                         </TableHead>
100                         <TableBody>
101                             {waterParameters.map((param) => (
102                                 <TableRow key={param.id}>
103                                     <TableCell>{format(parseISO(param.measured_at), 'yyyy-MM-dd HH:mm:ss')}</TableCell>
104                                     <TableCell>{param.ph}</TableCell>
105                                     <TableCell>{param.temperature}°C</TableCell>
106                                     <TableCell>{param.salinity}‰</TableCell>
107                                     <TableCell>{param.oxygen_level} mg/L</TableCell>
108                                 </TableRow>
109                             ))}
110                         </TableBody>
111                     </Table>
112                 </TableContainer>
113             </Paper>
114         </Container>
115     );
116 };
117
118 export default DeviceDetailPage;

ДОДАТОК В
Код IoT-частини

В.1 Код скетчу IoT

1 #define DHTPIN 15
2 #define DHTTYPE DHT22
3 DHT dht(DHTPIN, DHTTYPE);
4
5 #define SERVO_PIN 2
6 #define PH_PIN 14
7 #define SALINITY_PIN 13
8 #define OXYGEN_PIN 12
9
10 LiquidCrystal_I2C lcd(0x27, 16, 2);
11
12 const char* ssid = "Wokwi-GUEST";
13 const char* password = "";
14 const char* websockets_server = "host.wokwi.internal";
15 const uint16_t websockets_port = 8000;
16 const char* websockets_route = "/ws/ESP21_0";
17 const char* unique_address = "ESP21_0";
18
19
20 WebSocketsClient webSocket;
21 bool is_active = false;
22 bool is_connected = false;
23
24 void setup() {
25   Serial.begin(115200);
26   dht.begin();
27
28   Wire.begin();
29   lcd.init();
30   lcd.backlight();
31
32   pinMode(SERVO_PIN, OUTPUT);
33   pinMode(34, INPUT);
34   pinMode(32, INPUT);
35   pinMode(35, INPUT);
36
37   WiFi.begin(ssid, password);
38   while (WiFi.status() != WL_CONNECTED) {
39     delay(1000);
40     Serial.println("Підключення до WiFi...");
41   }
42   Serial.println("Підключено до WiFi");
43   Serial.print("IP адреса: ");
44   Serial.println(WiFi.localIP());
45
46   Serial.print("Підключення до WebSocket: ");
47   webSocket.begin(websockets_server, websockets_port, websockets_route);
48   webSocket.onEvent(webSocketEvent);
49   webSocket.setReconnectInterval(5000);
50   webSocket.enableHeartbeat(3000, 3000, 2);
51 }
52
53 void loop() {
54   webSocket.loop();
55
56   static unsigned long lastConnectionCheck = 0;
57   if (millis() - lastConnectionCheck > 5000) {
58     lastConnectionCheck = millis();
59     if (!is_connected) {
60       Serial.println("Спроба повторного підключення...");
61       webSocket.begin(websockets_server, websockets_port, websockets_route);
62     }
63   }
64
65   if (is_active && is_connected) {
66     static unsigned long lastTime = 0;
67     unsigned long now = millis();
68     if (now - lastTime > 600) {
69       lastTime = now;
70       //endSensorData();
71     }
72   } else {
73     updateStatusLCD(is_connected);
74   }
75 }
76
77 void webSocketEvent(WStype_t type, uint8_t * payload, size_t length) {
78   JsonDocument doc;
79
80   switch(type) {
81     case WStype_DISCONNECTED:
82       Serial.println("Від'єднано від WebSocket сервера");
83       is_connected = false;
84       updateStatusLCD(is_connected);
85       break;
86     case WStype_CONNECTED:
87       Serial.println("Підключено до WebSocket сервера");
88       is_connected = true;
89       updateStatusLCD(is_connected);
90       webSocket.sendTXT("{\"action\":\"identify\",\"unique_address\":\"" + String(unique_address) + "\"}");
91       break;
92     case WStype_TEXT:
93       Serial.printf("Отримано повідомлення: %s\n", payload);
94       if (deserializeJson(doc, payload) == DeserializationError::Ok) {
95         if (doc["action"] == "activate") {
96           is_active = true;
97           Serial.println("Пристрій активовано");
98         } else if (doc["action"] == "deactivate") {
99           is_active = false;
100           Serial.println("Пристрій деактивовано");
101           updateStatusLCD(is_connected);
102         } else if (doc["action"] == "feed" && is_active) {
103           feed();
104         }
105       } else {
106         Serial.println("Помилка розбору JSON");
107       }
108       break;
109     case WStype_ERROR:
110       Serial.println("Помилка WebSocket з'єднання");
111       break;
112     case WStype_PING:
113       Serial.println("Ping отримано");
114       break;
115     case WStype_PONG:
116       Serial.println("Pong отримано");
117       break;
118   }
119 }
120
121 void sendSensorData() {
122   if (!is_active) return;
123
124   float rawPH = analogRead(34);
125   float rawSalinity = analogRead(32);
126   float rawOxygen = analogRead(35);
127   float rawTemperature = dht.readTemperature();
128
129   JsonDocument doc;
130   doc["action"] = "water_parameters";
131   doc["unique_address"] = unique_address;
132   doc["parameters"]["ph"] = rawPH;
133   doc["parameters"]["temperature"] = rawTemperature;
134   doc["parameters"]["salinity"] = rawSalinity;
135   doc["parameters"]["oxygen_level"] = rawOxygen;
136
137   String jsonString;
138   serializeJson(doc, jsonString);
139   webSocket.sendTXT(jsonString);
140
141   updateLCD(rawTemperature, rawPH, rawSalinity, rawOxygen);
142
143   Serial.printf("pH: %.2f, Temperature: %.2f°C, Salinity: %.2f ppt, Oxygen: %.2f mg/L\n",
144                 rawPH, rawTemperature, rawSalinity, rawOxygen);
145 }
146
147 void updateLCD(float temp, float ph, float salinity, float oxygen) {
148   if (!is_active) return;
149
150   lcd.clear();
151   lcd.setCursor(0, 0);
152   lcd.printf("T:%.1f pH:%.1f", temp, ph);
153   lcd.setCursor(0, 1);
154   lcd.printf("S:%.1f O2:%.1f", salinity, oxygen);
155 }
156
157 void updateStatusLCD(bool connected) {
158   lcd.clear();
159   lcd.setCursor(0, 0);
160   lcd.print(connected ? "WS: Connected" : "WS: Disconnected");
161   lcd.setCursor(0, 1);
162   lcd.print(is_active ? "Device: Active" : "Device: Inactive");
163 }
164
165 void feed() {
166   if (is_active) {
167     Serial.println("Годування...");
168     for (int pos = 0; pos <= 180; pos += 1) {
169       digitalWrite(SERVO_PIN, HIGH);
170       delayMicroseconds(pos * 10 + 600);
171       digitalWrite(SERVO_PIN, LOW);
172       delay(20);
173     }
174     webSocket.sendTXT("{\"action\":\"feed_result\",\"success\":true,\"unique_address\":\"" + String(unique_address) + "\"}");
175     Serial.println("Годування завершено");
176
177     lcd.clear();
178     lcd.setCursor(0, 0);
179     lcd.print("Feeding...");
180     delay(2000);
181     sendSensorData();
182   }
183 }

ДОДАТОК Г
Діаграма активності IoT-частини


Рисунок Г.1 - Діаграма активності годування

